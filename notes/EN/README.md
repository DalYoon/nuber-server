# 1.1 Project Setup- Git & Installation

## section.log

- make project
- add basic dependencies
- config `tsconfig.json`, `tslint.json`

## tips

- `tsc --init` command will create tsconfig file automatically

## issue

- none

## links

- [tsconfig.json file](https://github.com/nomadcoders/nuber-server/blob/6ae7fc176776d85c987df1263edd7e05041b1661/tsconfig.json)
- [tslint.json file](https://github.com/nomadcoders/nuber-server/blob/6ae7fc176776d85c987df1263edd7e05041b1661/tslint.json)

## added dependencies

### dependencies

### devDependencies

- typescript
- ts-node
- nodemon
- tslint-config-prettier
- @types/node

---

# 1.2 Project Setup. Typescript and NodeJS

## section.log

- write script for cammand `yarn dev`

## tips

- the script below will monitor the change of .ts file and also .graphql file automatically (nodemon, ts-node)
- just make sure there is no space between file types `ts,graphql`, at the example below, <br>
  it looks like there is space after `ts,`, but it just automatically generated by stupid md generator, <br>
  i didn't put any space at there, and you shouldn't do that too

```json
package.json
...
"scripts": {
    "dev": "cd src && nodemon --exec ts-node index.ts -e ts, graphql"
}
...
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.3 A word on @types

## section.log

- explanation for the dependencies start with @types

## tips

- `@types` dependencies are just type definitions for the follow dependencies after `@types/`

```
  @types/node: type definitions for node
  @types/express: type definitions for express
  .
  .
  .
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.4 GraphQL Yoga and Express part One

## section.log

- add graphql-yoga dependency
- add middleware dependencies, and `@types` for each of them
- code `./src/app.ts` for basic setting of graphql-yoga, middlewares

## tips

- graphql-yoga contains the dependencies below

  - express/apollo-server: Performant, extensible web server framework
  - graphql-subscriptions/subscriptions-transport-ws: GraphQL subscriptions server
  - graphql.js/graphql-tools: GraphQL engine & schema helpers
  - graphql-playground: Interactive GraphQL IDE

- be careful to install `@types` dependencies at **devDependencies**
- just make sure import `cors` **before** import `graphql-yoga` in `./src/app.ts` file

```javascript
import cors from "cors";
import { GraphQLServer } from "graphql-yoga";
```

## issue

- none

## links

## added dependencies

### dependencies

- graphql-yoga
- helmet
- morgan
- cors

### devDependencies

- @types/helmet
- @types/morgan
- @types/cors

---

# 1.5 GraphQL Yoga and Express part Two

## section.log

- code `./src/index.ts` for running graphql-yoga

## tips

- check `Options` in `graphql-yoga`

## issue

- none

## links

- [graphql-yoga docs](https://github.com/prismagraphql/graphql-yoga/blob/master/README.md)

## added dependencies

### dependencies

### devDependencies

---

# 1.6 API and Schema Structue part One

## section.log

- explanation for basic schema and query structure
- create `./src/api/` for defining types, resolvers
- create `./src/schema.ts` for merging types, resolvers

## tips

- `./src/api/` directory have types, queries, resolvers to handle datas
- `./src/schema.ts` file merges `./src/api/` directory which is every types, resolvers
- `merge-graphql-schemas` dependency doesn't have `type` definition. So when you import this dependency in your code, vcs wouldn't give you any description or guide for type of it. Don't panic. It's totally fine

```javascript
import { fileLoader, mergeResolvers, mergeTypes } from "merge-graphql-schemas";
```

- `path` is provided by `node` as default

## issue

- none

## links

[merge-graphql-schemas docs](https://github.com/okgrow/merge-graphql-schemas)

## added dependencies

### dependencies

- graphql-tools
- merge-graphql-schemas

### devDependencies

---

# 1.7 API and Schema Structue part Two

## section.log

- write `./src/schema.ts` file for merging `query`, `resolvers`
- get `.graphql`, `resolvers` file with through `fileLoader/merge-graphql-schemas`
- merge it, put it into `makeExcutableSchema/graphql-tools`
- put generated schema into `GraphqlServer.schema`

## tips

- `path.join(__dirname, './')` returns `/files/current/directory/`

```javascript
// sample code (code path = ~project-path/nuber-server/src/test.js)
const path = require("path");
const myPath = path.join(__dirname, "./");
console.log(myPath);

// it returns => ~project-path/nuber-server/src/
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.8 Graphql To Typescript

## section.log

- very important leture
- how to merge types
- make script to merge types

## tips

### types merging process:

1.  with `gql-merge`, merge all `.graphql` files in `./src/api/` into one file `./src/schema.graphql`
2.  with `graphql-to-typescript`, merge all types in `./src/schema.graphql` to `./src/types/graph.d.ts`

```json
// script sample
package.json
...
"script": {
    "pretypes": "gql-merge --out-file ./src/schema.graphql ./src/api/**/*.graphql",
    "types": "graphql-to-typescript ./src/schema.graphql ./types/graph.d.ts",
}
...
```

- to proceed merging process above, you need `babel-rumtime` as dev dependency
- after all, you can get `graph.d.ts` file, and it contains all types you defined in every `.graphql` files, <br>
  so you are able to call your custom types for your typescript code, for example like resolvers

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

- graphql-to-typescript
- gql-merge
- babel-runtime

---

# 1.9 Typechecking Graphql Arguments

## section.log

- define query argument and merge it to type
- usage for merged query argument types

## tips

- the name of merged type for query argument is `query name` + `root query name` + `Args`, check the example below

```graphql
# .graphql type definition
type Query {
  sayHello(name: String!): SayHelloResponse!
}
```

```typescript
// merged type in graphql.d.ts
export interface SayHelloQueryArgs {
  name: string;
}
```

- the argument: `name` of sayHello Query in `.graphql` goes interface: `SayHelloQueryArgs` in `graph.d.ts`

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.10 Configuring TypeORM

## section.log

- basic setting for typeorm
- make `ConnectionOptions`

## tips

- for using `psql` command, `postgres-client` should be installed

## issue

- none

## links

## added dependencies

### dependencies

- typeorm
- pg

### devDependencies

---

# 1.11 Creating a Virtual Environment on NodeJS

## section.log

- set `.env` file to define additional project environment for connecting databse
- create connection with database

## tips

- `dotenv.config()` automatically read `.env` file and put it into `process.env`
- just make sure to import `dotenv` and `dotenv.config()` **before** call `connectOptions`;

```typescript
import dotenv from "dotenv";
dotenv.config();
import connectionOptions from "./ormConfig";
```

## issue

- none

## links

## added dependencies

### dependencies

- dotenv

### devDependencies

---

# 1.12 User Entity GraphQL Type

## section.log

- define user type `User.graphql`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.13 User Entity part One

## section.log

- write `User.ts` entity for `User model`

## tips

- `class validator` validates custom decorators like `email decorator`

## issue

- none

## links

- [class validator](https://github.com/typestack/class-validator)

## added dependencies

### dependencies

- class-validator

### devDependencies

---

# 1.14 User Entity part Two

## section.log

- write `User.ts` for `User Entity`

## tips

- `synchronize` option in `ormConfig.ts` gives auto migrations for entities
- simple example for generating data in entity

```typescript
// ~/Entity/User.ts
...
@Column({ type: "text" })
  firstName: string;

@Column({ type: "text" })
  lastName: string;

get fullname(): string {
  return `${this.firstName} ${this.lastName}`;
}
...
```

## issue

- none

## links

## added dependencies

### dependencies

- bcrypt

### devDependencies

- @types/bcrypt

---

# 1.15 Hashing and Encrypting User Passwords

## section.log

- process for hashing password
- `@BeforeInsert`, `@BeforeUpdate` decorators

## tips

- hashing process:
- hash salt

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.16 Verifying User Password

## section.log

- verify password with `bcrypt.compare` function

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.17 Verification Entity part One

## section.log

- define type and entity for verification

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.18 Using Types on the Entities

## section.log

- define custom definition which has limited options
- add script for generating types automatically

## tips

- you can custom definition in `types/<name whatever>.d.ts`, check the usage below

```typescript
// types/test.d.ts
export type sayWhatever = "Hello" | "Bye";
```

```typescript
// entities/Test.ts
import { sayWhatever } from 'path for <test.d.ts>'

...
@Column()
message: sayWhatever;
```

- the code above, gives only limited available input strings to `message` column ("Hello, "Bye")

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.19 Creating the Verification Key

## section.log

- how to generate key with native javascript function `Math.floor()`, `Math.random()`, `Math.floor()`, `toString()`, `toString(36)`, `substr()`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.20 Place Entity

## section.log

-

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.20 Place Entity

## section.log

- define entity and type for `Place`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.21 Ride Entity

## section.log

- define entity and type for `Ride`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.22 Chat and Message Entities part One

## section.log

- very important lecture
- define entities and types for `Chat`, `Message` and entity relationships

## tips

- relationship definition process:
  `add argument for joining other entity in each of types`
  -> `use @OneToMany, @ManyToOne decorators to match column`
- checkout the usage below

```typescript
// entities/Classroom.ts
import Student from './Student'

@OneToMany(type => Student, student => student.classroom)
students: Student[];
```

```typescript
// entities/Student.ts
import Classroom from './Classroom'

@ManyToOne(type => Classroom, classroom => classroom.students)
classroom: Classroom;
```

## issue

- none

## links

- [typeorm one-to-many, many-to-one relationship guide](https://github.com/typeorm/typeorm/blob/master/docs/many-to-one-one-to-many-relations.md)

## added dependencies

### dependencies

### devDependencies

---

# 1.23 Chat and Message Entities part Two

## section.log

- define relationship between `User`, `Chat` entities

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.24 Model Relationships like a Boss

## section.log

- define relationship between `User`, `Verification`
- define relationship between `User`, `Ride`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.25 Resolver Types

## section.log

- define `resolver` definition

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.26 Planning the Resolvers part One

## section.log

- write features lists

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.27 Planning the Resolvers part Two

## section.log

- write features lists

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.28 FacebookConnect Resolver part One

## section.log

- define mutation type for `facebook connect`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.29 FacebookConnect Resolver part Two

## section.log

- very important lecture
- how to define resolver, catch error
- how to select user in db

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.30 FacebookConnect Resolver part Three

## section.log

- very important lecture
- make resolver for creating user, inserting user data into database

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.31 Testing the FacebookConnect Resolver

## section.log

- test the mutation
- adjust for nullable columns

## tips

## issue

- the mutation returned `"error": "value \"<facebook id>\" is out of range for type integer"`
  - Question: WTF does that mean 'fbId' is integer, I defined it as string, let's look
    - [x] in `User.graphql`, fbId: String
    - [x] in `entities/User.ts`, `@Column({ type: "text", nullable: true }) fbId: string;
    - [x] in `types/types.d.ts`, `FacebookConnectMutationArgs` fbId: string;
  - Reason
    - in `resolver`, checking existing user<br>
      ~`const existingUser = await User.findOne(fbId)`~<br>
      `const existingUser = await User.findOne({ fbId })`<br>

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.32 EmailSignIn Resolver part One

## section.log

- define email sign in resolver, type

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.33 EmailSignIn Resolver part Two

## section.log

- define email sign in resolver, type

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.34 Introduction to Twilio

## section.log

- very important lecture
- introduce **Twilio**

## tips

## issue

- none

## links

[Twilio](https://www.twilio.com/)

## added dependencies

### dependencies

### devDependencies

---

# 1.35 StartPhoneVerification Resolver part One

## section.log

- make twilio account, phone number to send SMS
- define resolver for verification
- adjust types, columns

## tips

## issue

- none

## links

## added dependencies

### dependencies

- twilio

### devDependencies

- @types/twilio

---

# 1.36 StartPhoneVerification Resolver part Two

## section.log

- very important lecture
- write code for sending SMS

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.37 StartPhoneVerification Resolver part Three (Sending SMS)

## section.log

- define verification resolver for sending verification SMS

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.38 CompletePhoneVerification part One

## section.log

- define type and resolver for `Complete Verification`
- explain verification flow
- @Colummn verified: false??

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.39 CompletePhoneVerification part Two

## section.log

- very important lecture
- vericifation process

## tips

### phone verification process:

1.  user inputs phone number and click `send verification key` button
2.  it calls `StartPhoneVerification` mutation with phone number to verify
3.  `StartPhoneVericitaion` resolver inserts a verification data below

```json
verification {
    "target": "PHONE",
    "payload": "<phone number>",
    "key": "<verification key generated by `@BeforeInsert` in entity>",
    "verified": false(default),
    "createdAt": "<created time>",
    "updatedAt": "<updated time>"
}
```

4.  then, resolver calls `sendSMS/sendVerification` with payload(phone number), key(generated above) - sending SMS
5.  user checks the SMS(user's got key at thie point)
6.  user input the key, then click `verify` button
7.  the button calls `CompletePhoneVerification` mutation with payload(phone number), key(what user input in step 6)
8.  it finds the same pair in the Verification data
9.  finish verification
    - if same pair be found, it finds the user who has same phone number and changes verification status<br>
      `Verification.verified = true;`<br>
      `User.verifiedPhoneNumber = true;`
    - if the phone number and key are not matched, it returns an error

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.40 EmailSignUp Resolver

## section.log

- define type, resolver for `EmailSignUp`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.41 Creating Custom JWT

## section.log

- define `createJWT`

## tips

## issue

- JWT secret should be `string`, but if you define 'secret' in `.env` file.<br>
  the type of it is `string | undefined`

## links

## added dependencies

### dependencies

- jsonwebtoken

### devDependencies

- @types/jsonwebtoken

---

# 1.42 Authenticating Users with Custom JWT

## section.log

- very important lecture
- finish generating token

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.43 Testing Authentication Resolvers

## section.log

- test!

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.44 Custom Auth Middleware on Express part One

## section.log

- start to make middleware for authentication

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.45 Custom Auth Middleware on Express part Two

## section.log

- define `decodeJWT`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.46 Using Resolver Context for Authentication

## section.log

- very important lecture
- how to recognize users with token
- introduction for `context`

## tips

### process to get the current user information:

1.  after sign in, browser puts user's JWT token in their request header
2.  express middleware catchs that JWT token
3.  `decodeJWT` util decodes the JWT token, and find the user who the token points at
4.  put user information into `request.context`
5.  every resolvers takes `context` as argument, check the resolver type below

```typescript
export type Resolver = (parent: any, args: any, context: any, info: any) => any;

export interface Resolvers {
  [key: string]: {
    [key: string]: Resolver;
  };
}
```

6.  you can get the information in `context` through resolver's 3rd argument(context)
7.  then, do whatever you want

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.47 GetMyProfile Resolver

## section.log

- define `GetMyProfile` query

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.48 Protecting Resolvers with Middlewares

## section.log

- separate query resolver with currying

## tips

- to project resolver, you can divide query by currying<br>
  why is that? i don't know(i'll add this part once i figure it out)

## issue

- none

## links

- [JS Currying - KR](https://www.haruair.com/blog/2993)

## added dependencies

### dependencies

### devDependencies

---

# 1.49 Sending Confirmation Email part One

## section.log

- define `sendEmail.ts` with `mailgun` for verification mail

## tips

## issue

- none

## links

- [mailgun](https://www.mailgun.com/)

## added dependencies

### dependencies

- mailgun-js

### devDependencies

- @types/mailgun-js

---

# 1.50 Sending Confirmation Email part Two

## section.log

- add email verification process in `EmailSignUp` resolver;

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.51 Sending Confirmation Email part Three

## section.log

- add email verification process in `EmailSignUp` resolver;
- bug fix on phone verification
- database reset

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.52 Testing Email Sending

## section.log

- test functions below
  - `startPhoneVerification`
  - `completePhoneVerification`
  - `emailSignUp`
  - `emailVerification`

## tips

## issue

### after emailSignUp, i haven't received any verification email

- Check
  - [x] check mail log on mailgun dashboard (mail delivered)
- Reason
  - the mail has processed as spam (it was in the spam mail box)

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.53 RequestEmailVerification Resolver

## section.log

- define `RequestEmailVerification` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.54 CompleteEmailVerification Resolver

## section.log

- define `CompleteEmailVerification` Resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.55 Testing Email Verification Resolvers

## section.log

- test functions below
  - `RequestEmailVerification` resolver
  - `CompleteEmailVerification` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.56 UpdateMyProfile Resolver part One

## section.log

- define `UpdateMyProfile` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.57 UpdateMyProfile Resolver part Two

## section.log

- define `UpdateMyProfile` resolver

## tips

### cleanNullArgs Function

- between 1.57 and 1.57.1 there is little difference, `cleanNullArgs` <br>
  you will define it on the lecture 1.59, don't be panic
  it's just nothing more than seprating code that filtering null data

### exmaple for filtering the datas those have null value

```javascript
const args = {
  firstName: null,
  lastName: null,
  email: "test@test.com",
  password: "changedPassword",
  profilePhoto: null,
  age: 50
};
const notNull = {};

Object.keys(args).forEach(key => {
  if (args[key] !== null) {
    notNull[key] = args[key];
  }
});

console.log(notNull);
// result
// notNull = {
//     email: "test@test.com",
//     password: "changedPassword",
//     age: 50
// }
```

### diffences between the ways to update data to Entity

```javascript
// 1.
const user = await User.findOne({id: userId});
if(user) {
  user.firstName = "newFirstName";
  user.save();
}

// 2.
User.update({id: userId}, { firstName: "newFirstName"});
```

- 1, 2 both do same thing, find the data which has userId at id column and updates firstName column to 'newFirstName'<br>
  but the code 1 calls `@BeforeUpdate`, and the code 2 doesn't<br>
  in the code above, `User` and `user` are different, `User` is User Entity itself, and `user` is a user instance from Entity<br>
  just make sure for that

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.58 ToggleDrivingMode Resolver

## section.log

- define `ToggleDrivingMode` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.59 ReportMovement Resolver

## section.log

- define `ReportMovement` resolver
- separate `cleanNullArgs`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.60 AddPlace Resolver

## section.log

- define `AddPlace` resolver
- adjust `User`, `Place` Entities for adding each users places

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.62 DeletePlace Resolver

## section.log

- define `DeletePlace` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---
