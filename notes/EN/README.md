# 1.1 Project Setup- Git & Installation

## section.log

- make project
- add basic dependencies
- config `tsconfig.json`, `tslint.json`

## tips

- `tsc --init` command will create tsconfig file automatically

## issue

- none

## links

- [tsconfig.json file](https://github.com/nomadcoders/nuber-server/blob/6ae7fc176776d85c987df1263edd7e05041b1661/tsconfig.json)
- [tslint.json file](https://github.com/nomadcoders/nuber-server/blob/6ae7fc176776d85c987df1263edd7e05041b1661/tslint.json)

## added dependencies

### dependencies

### devDependencies

- typescript
- ts-node
- nodemon
- tslint-config-prettier
- @types/node

---

# 1.2 Project Setup. Typescript and NodeJS

## section.log

- write script for cammand `yarn dev`

## tips

- the script below will monitor the change of .ts file and also .graphql file automatically (nodemon, ts-node)
- just make sure there is no space between file types `ts,graphql`, at the example below, <br>
  it looks like there is space after `ts,`, but it just automatically generated by stupid md generator, <br>
  i didn't put any space at there, and you shouldn't do that too

```json
package.json
...
"scripts": {
    "dev": "cd src && nodemon --exec ts-node index.ts -e ts, graphql"
}
...
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.3 A word on @types

## section.log

- explanation for the dependencies start with @types

## tips

- `@types` dependencies are just type definitions for the follow dependencies after `@types/`

```
  @types/node: type definitions for node
  @types/express: type definitions for express
  .
  .
  .
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.4 GraphQL Yoga and Express part One

## section.log

- add graphql-yoga dependency
- add middleware dependencies, and `@types` for each of them
- code `./src/app.ts` for basic setting of graphql-yoga, middlewares

## tips

- graphql-yoga contains the dependencies below

  - express/apollo-server: Performant, extensible web server framework
  - graphql-subscriptions/subscriptions-transport-ws: GraphQL subscriptions server
  - graphql.js/graphql-tools: GraphQL engine & schema helpers
  - graphql-playground: Interactive GraphQL IDE

- be careful to install `@types` dependencies at **devDependencies**
- just make sure import `cors` **before** import `graphql-yoga` in `./src/app.ts` file

```javascript
import cors from "cors";
import { GraphQLServer } from "graphql-yoga";
```

## issue

- none

## links

## added dependencies

### dependencies

- graphql-yoga
- helmet
- morgan
- cors

### devDependencies

- @types/helmet
- @types/morgan
- @types/cors

---

# 1.5 GraphQL Yoga and Express part Two

## section.log

- code `./src/index.ts` for running graphql-yoga

## tips

- check `Options` in `graphql-yoga`

## issue

- none

## links

- [graphql-yoga docs](https://github.com/prismagraphql/graphql-yoga/blob/master/README.md)

## added dependencies

### dependencies

### devDependencies

---

# 1.6 API and Schema Structue part One

## section.log

- explanation for basic schema and query structure
- create `./src/api/` for defining types, resolvers
- create `./src/schema.ts` for merging types, resolvers

## tips

- `./src/api/` directory have types, queries, resolvers to handle datas
- `./src/schema.ts` file merges `./src/api/` directory which is every types, resolvers
- `merge-graphql-schemas` dependency doesn't have `type` definition. So when you import this dependency in your code, vcs wouldn't give you any description or guide for type of it. Don't panic. It's totally fine

```javascript
import { fileLoader, mergeResolvers, mergeTypes } from "merge-graphql-schemas";
```

- `path` is provided by `node` as default

## issue

- none

## links

[merge-graphql-schemas docs](https://github.com/okgrow/merge-graphql-schemas)

## added dependencies

### dependencies

- graphql-tools
- merge-graphql-schemas

### devDependencies

---

# 1.7 API and Schema Structue part Two

## section.log

- write `./src/schema.ts` file for merging `query`, `resolvers`
- get `.graphql`, `resolvers` file with through `fileLoader/merge-graphql-schemas`
- merge it, put it into `makeExcutableSchema/graphql-tools`
- put generated schema into `GraphqlServer.schema`

## tips

- `path.join(__dirname, './')` returns `/files/current/directory/`

```javascript
// sample code (code path = ~project-path/nuber-server/src/test.js)
const path = require("path");
const myPath = path.join(__dirname, "./");
console.log(myPath);

// it returns => ~project-path/nuber-server/src/
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.8 Graphql To Typescript

## section.log

- very important leture
- how to merge types
- make script to merge types

## tips

### types merging process:

1.  with `gql-merge`, merge all `.graphql` files in `./src/api/` into one file `./src/schema.graphql`
2.  with `graphql-to-typescript`, merge all types in `./src/schema.graphql` to `./src/types/graph.d.ts`

```json
// script sample
package.json
...
"script": {
    "pretypes": "gql-merge --out-file ./src/schema.graphql ./src/api/**/*.graphql",
    "types": "graphql-to-typescript ./src/schema.graphql ./types/graph.d.ts",
}
...
```

- to proceed merging process above, you need `babel-rumtime` as dev dependency
- after all, you can get `graph.d.ts` file, and it contains all types you defined in every `.graphql` files, <br>
  so you are able to call your custom types for your typescript code, for example like resolvers

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

- graphql-to-typescript
- gql-merge
- babel-runtime

---

# 1.9 Typechecking Graphql Arguments

## section.log

- define query argument and merge it to type
- usage for merged query argument types

## tips

- the name of merged type for query argument is `query name` + `root query name` + `Args`, check the example below

```graphql
# .graphql type definition
type Query {
  sayHello(name: String!): SayHelloResponse!
}
```

```typescript
// merged type in graphql.d.ts
export interface SayHelloQueryArgs {
  name: string;
}
```

- the argument: `name` of sayHello Query in `.graphql` goes interface: `SayHelloQueryArgs` in `graph.d.ts`

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.10 Configuring TypeORM

## section.log

- basic setting for typeorm
- make `ConnectionOptions`

## tips

- for using `psql` command, `postgres-client` should be installed

## issue

- none

## links

## added dependencies

### dependencies

- typeorm
- pg

### devDependencies

---

# 1.11 Creating a Virtual Environment on NodeJS

## section.log

- set `.env` file to define additional project environment for connecting databse
- create connection with database

## tips

- `dotenv.config()` automatically read `.env` file and put it into `process.env`
- just make sure to import `dotenv` and `dotenv.config()` **before** call `connectOptions`;

```typescript
import dotenv from "dotenv";
dotenv.config();
import connectionOptions from "./ormConfig";
```

## issue

- none

## links

## added dependencies

### dependencies

- dotenv

### devDependencies

---

# 1.12 User Entity GraphQL Type

## section.log

- define user type `User.graphql`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.13 User Entity part One

## section.log

- write `User.ts` entity for `User model`

## tips

- `class validator` validates custom decorators like `email decorator`

## issue

- none

## links

- [class validator](https://github.com/typestack/class-validator)

## added dependencies

### dependencies

- class-validator

### devDependencies

---

# 1.14 User Entity part Two

## section.log

- write `User.ts` for `User Entity`

## tips

- `synchronize` option in `ormConfig.ts` gives auto migrations for entities
- simple example for generating data in entity

```typescript
// ~/Entity/User.ts
...
@Column({ type: "text" })
  firstName: string;

@Column({ type: "text" })
  lastName: string;

get fullname(): string {
  return `${this.firstName} ${this.lastName}`;
}
...
```

## issue

- none

## links

## added dependencies

### dependencies

- bcrypt

### devDependencies

- @types/bcrypt

---

# 1.15 Hashing and Encrypting User Passwords

## section.log

- process for hashing password
- `@BeforeInsert`, `@BeforeUpdate` decorators

## tips

- hashing process:
- hash salt

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.16 Verifying User Password

## section.log

- verify password with `bcrypt.compare` function

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.17 Verification Entity part One

## section.log

- define type and entity for verification

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.18 Using Types on the Entities

## section.log

- define custom definition which has limited options
- add script for generating types automatically

## tips

- you can custom definition in `types/<name whatever>.d.ts`, check the usage below

```typescript
// types/test.d.ts
export type sayWhatever = "Hello" | "Bye";
```

```typescript
// entities/Test.ts
import { sayWhatever } from 'path for <test.d.ts>'

...
@Column()
message: sayWhatever;
```

- the code above, gives only limited available input strings to `message` column ("Hello, "Bye")

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.19 Creating the Verification Key

## section.log

- how to generate key with native javascript function `Math.floor()`, `Math.random()`, `Math.floor()`, `toString()`, `toString(36)`, `substr()`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.20 Place Entity

## section.log

-

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.20 Place Entity

## section.log

- define entity and type for `Place`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.21 Ride Entity

## section.log

- define entity and type for `Ride`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.22 Chat and Message Entities part One

## section.log

- very important lecture
- define entities and types for `Chat`, `Message` and entity relationships

## tips

- relationship definition process:
  `add argument for joining other entity in each of types`
  -> `use @OneToMany, @ManyToOne decorators to match column`
- checkout the usage below

```typescript
// entities/Classroom.ts
import Student from './Student'

@OneToMany(type => Student, student => student.classroom)
students: Student[];
```

```typescript
// entities/Student.ts
import Classroom from './Classroom'

@ManyToOne(type => Classroom, classroom => classroom.students)
classroom: Classroom;
```

## issue

- none

## links

- [typeorm one-to-many, many-to-one relationship guide](https://github.com/typeorm/typeorm/blob/master/docs/many-to-one-one-to-many-relations.md)

## added dependencies

### dependencies

### devDependencies

---

# 1.23 Chat and Message Entities part Two

## section.log

- define relationship between `User`, `Chat` entities

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.24 Model Relationships like a Boss

## section.log

- define relationship between `User`, `Verification`
- define relationship between `User`, `Ride`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.25 Resolver Types

## section.log

- define `resolver` definition

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.26 Planning the Resolvers part One

## section.log

- write features lists

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.27 Planning the Resolvers part Two

## section.log

- write features lists

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.28 FacebookConnect Resolver part One

## section.log

- define mutation type for `facebook connect`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.29 FacebookConnect Resolver part Two

## section.log

- very important lecture
- how to define resolver, catch error
- how to select user in db

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.30 FacebookConnect Resolver part Three

## section.log

- very important lecture
- make resolver for creating user, inserting user data into database

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.31 Testing the FacebookConnect Resolver

## section.log

- test the mutation
- adjust for nullable columns

## tips

## issue

- the mutation returned `"error": "value \"<facebook id>\" is out of range for type integer"`
  - Question: WTF does that mean 'fbId' is integer, I defined it as string, let's look
    - [x] in `User.graphql`, fbId: String
    - [x] in `entities/User.ts`, `@Column({ type: "text", nullable: true }) fbId: string;
    - [x] in `types/types.d.ts`, `FacebookConnectMutationArgs` fbId: string;
  - Reason
    - in `resolver`, checking existing user<br>
      ~`const existingUser = await User.findOne(fbId)`~<br>
      `const existingUser = await User.findOne({ fbId })`<br>

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.32 EmailSignIn Resolver part One

## section.log

- define email sign in resolver, type

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.33 EmailSignIn Resolver part Two

## section.log

- define email sign in resolver, type

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.34 Introduction to Twilio

## section.log

- very important lecture
- introduce **Twilio**

## tips

## issue

- none

## links

[Twilio](https://www.twilio.com/)

## added dependencies

### dependencies

### devDependencies

---

# 1.35 StartPhoneVerification Resolver part One

## section.log

- make twilio account, phone number to send SMS
- define resolver for verification
- adjust types, columns

## tips

## issue

- none

## links

## added dependencies

### dependencies

- twilio

### devDependencies

- @types/twilio

---

# 1.36 StartPhoneVerification Resolver part Two

## section.log

- very important lecture
- write code for sending SMS

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.37 StartPhoneVerification Resolver part Three (Sending SMS)

## section.log

- define verification resolver for sending verification SMS

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.38 CompletePhoneVerification part One

## section.log

- define type and resolver for `Complete Verification`
- explain verification flow
- @Colummn verified: false??

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.39 CompletePhoneVerification part Two

## section.log

- very important lecture
- vericifation process

## tips

### phone verification process:

1.  user inputs phone number and click `send verification key` button
2.  it calls `StartPhoneVerification` mutation with phone number to verify
3.  `StartPhoneVericitaion` resolver inserts a verification data below

```json
verification {
    "target": "PHONE",
    "payload": "<phone number>",
    "key": "<verification key generated by `@BeforeInsert` in entity>",
    "verified": false(default),
    "createdAt": "<created time>",
    "updatedAt": "<updated time>"
}
```

4.  then, resolver calls `sendSMS/sendVerification` with payload(phone number), key(generated above) - sending SMS
5.  user checks the SMS(user's got key at thie point)
6.  user input the key, then click `verify` button
7.  the button calls `CompletePhoneVerification` mutation with payload(phone number), key(what user input in step 6)
8.  it finds the same pair in the Verification data
9.  finish verification
    - if same pair be found, it finds the user who has same phone number and changes verification status<br>
      `Verification.verified = true;`<br>
      `User.verifiedPhoneNumber = true;`
    - if the phone number and key are not matched, it returns an error

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.40 EmailSignUp Resolver

## section.log

- define type, resolver for `EmailSignUp`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.41 Creating Custom JWT

## section.log

- define `createJWT`

## tips

## issue

- JWT secret should be `string`, but if you define 'secret' in `.env` file.<br>
  the type of it is `string | undefined`

## links

## added dependencies

### dependencies

- jsonwebtoken

### devDependencies

- @types/jsonwebtoken

---

# 1.42 Authenticating Users with Custom JWT

## section.log

- very important lecture
- finish generating token

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.43 Testing Authentication Resolvers

## section.log

- test!

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.44 Custom Auth Middleware on Express part One

## section.log

- start to make middleware for authentication

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.45 Custom Auth Middleware on Express part Two

## section.log

- define `decodeJWT`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.46 Using Resolver Context for Authentication

## section.log

- very important lecture
- how to recognize users with token
- introduction for `context`

## tips

### process to get the current user information:

1.  after sign in, browser puts user's JWT token in their request header
2.  express middleware catchs that JWT token
3.  `decodeJWT` util decodes the JWT token, and find the user who the token points at
4.  put user information into `request.context`
5.  every resolvers takes `context` as argument, check the resolver type below

```typescript
export type Resolver = (parent: any, args: any, context: any, info: any) => any;

export interface Resolvers {
  [key: string]: {
    [key: string]: Resolver;
  };
}
```

6.  you can get the information in `context` through resolver's 3rd argument(context)
7.  then, do whatever you want

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.47 GetMyProfile Resolver

## section.log

- define `GetMyProfile` query

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.48 Protecting Resolvers with Middlewares

## section.log

- separate query resolver with currying

## tips

- to project resolver, you can divide query by currying<br>
  why is that? i don't know(i'll add this part once i figure it out)

## issue

- none

## links

- [JS Currying - KR](https://www.haruair.com/blog/2993)

## added dependencies

### dependencies

### devDependencies

---

# 1.49 Sending Confirmation Email part One

## section.log

- define `sendEmail.ts` with `mailgun` for verification mail

## tips

## issue

- none

## links

- [mailgun](https://www.mailgun.com/)

## added dependencies

### dependencies

- mailgun-js

### devDependencies

- @types/mailgun-js

---

# 1.50 Sending Confirmation Email part Two

## section.log

- add email verification process in `EmailSignUp` resolver;

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.51 Sending Confirmation Email part Three

## section.log

- add email verification process in `EmailSignUp` resolver;
- bug fix on phone verification
- database reset

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.52 Testing Email Sending

## section.log

- test functions below
  - `startPhoneVerification`
  - `completePhoneVerification`
  - `emailSignUp`
  - `emailVerification`

## tips

## issue

### after emailSignUp, i haven't received any verification email

- Check
  - [x] check mail log on mailgun dashboard (mail delivered)
- Reason
  - the mail has processed as spam (it was in the spam mail box)

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.53 RequestEmailVerification Resolver

## section.log

- define `RequestEmailVerification` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.54 CompleteEmailVerification Resolver

## section.log

- define `CompleteEmailVerification` Resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.55 Testing Email Verification Resolvers

## section.log

- test functions below
  - `RequestEmailVerification` resolver
  - `CompleteEmailVerification` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.56 UpdateMyProfile Resolver part One

## section.log

- define `UpdateMyProfile` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.57 UpdateMyProfile Resolver part Two

## section.log

- define `UpdateMyProfile` resolver

## tips

### cleanNullArgs Function

- bjust for everyone's information,<br>
  between 1.57 and 1.57.1 there is a little difference, 'cleanNullArgs' function that imported above<br>
  you will define it at the lecture 1.59<br>
  this function basically does same thing with we just did in 1.57 <br>
  it just takes an object, and filters out null datas from the object , and then, returns new object that doesn't contain any null datas in it

### exmaple for filtering the datas those have null value

```javascript
const args = {
  firstName: null,
  lastName: null,
  email: "test@test.com",
  password: "changedPassword",
  profilePhoto: null,
  age: 50
};
const notNull = {};

Object.keys(args).forEach(key => {
  if (args[key] !== null) {
    notNull[key] = args[key];
  }
});

console.log(notNull);
// result
// notNull = {
//     email: "test@test.com",
//     password: "changedPassword",
//     age: 50
// }
```

### diffences between the ways to update data to Entity

```javascript
// 1.
const user = await User.findOne({id: userId});
if(user) {
  user.firstName = "newFirstName";
  user.save();
}

// 2.
User.update({id: userId}, { firstName: "newFirstName"});
```

- 1, 2 both do same thing, find the data which has userId at id column and updates firstName column to 'newFirstName'<br>
  but the code 1 calls `@BeforeUpdate`, and the code 2 doesn't<br>
  in the code above, `User` and `user` are different, `User` is User Entity itself, and `user` is a user instance from Entity<br>
  just make sure for that

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.58 ToggleDrivingMode Resolver

## section.log

- define `ToggleDrivingMode` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.59 ReportMovement Resolver

## section.log

- define `ReportMovement` resolver
- separate `cleanNullArgs`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.60 AddPlace Resolver

## section.log

- define `AddPlace` resolver
- adjust `User`, `Place` Entities for adding each users places

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.62 DeletePlace Resolver

## section.log

- define `DeletePlace` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.63 GetMyPlaces Resolver and Testing

## section.log

- define `GetMyPlaces` resolver

## tips

- how to get the datas in relational field

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.64 GetNearbyDrivers Resolver part One

## section.log

- define `GetNearbyDrivers` resolver

## tips

## issue

- none

## links

- [Typeorm find options](https://github.com/typeorm/typeorm/blob/master/docs/find-options.md)

## added dependencies

### dependencies

### devDependencies

---

# 1.65 GetNearbyDrivers Resolver part Two

## section.log

- very important lecture
- what's the difference between `Active Record`, `Data Mapper` in typeorm
- define `GetNearbyDrivers` resolver with `Data Mapper`

## tips

### Ative Record vs Data Mapper (from typeorm docs)

> In TypeORM you can use both the Active Record and the Data Mapper patterns.

> Using the Active Record approach, you define all your query methods inside the model itself, and you save, remove, and load objects using model methods.

> Using the Data Mapper approach, you define all your query methods in separate classes called "repositories", and you save, remove, and load objects using repositories. In data mapper your entities are very dumb - they just define their properties and may have some "dummy" methods.

## issue

- none

## links

- [Active Record vs Data Mapper](https://github.com/typeorm/typeorm/blob/master/docs/active-record-data-mapper.md)

## added dependencies

### dependencies

### devDependencies

---

# 1.66 DriversSubscription part One

## section.log

- very important lecture
- introduce pub sub service
- define `DriversSubscription` resolver

## tips

- pubsub

  - subscription service that given by graphql-yoga
  - but it is not appropriate for production (why? don't know)

- in this course, pubsub structure will be discussed for 3 lectures

  - 1.66 - make channel for publishing, subscribing
  - 1.67 - make publishment to the channel
  - 1.68 - make subscription to follow the channel

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.67 DriversSubscription part Two

## section.log

- very important lecture
- add publish for `DriversSubscription` in `ReportMovement` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.68 Authenticating WebSocket Subscriptions part One

## section.log

- very important lecture
- define subscription option
- authorization with subscription

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.69 Authenticating WebSocket Subscriptions part Two

## section.log

- very important lecture
- how to get currentUser from `onConnect` with `subscription`

## tips

### getting currentUser with onConnect and subscription

1.  put JWT token in header (client)
2.  on graphql-yoga options, get JWT header with `onConnect` (server)
3.  decode JWT token, and return it as `currentUser`
4.  get `currentUser` from `request.connection.context.currentUser`
5.  then, put `currentUser` into `request.context`

```typescript
// in graphql-yoga options, step 1 - 3
subscriptions: {
    path: SUBSCRIPTION_ENDPOINT,
    onConnect: async connectionParams => {
      const token = await connectionParams["X-JWT"];
      if (token) {
        const user = decodeJWT(token);
        if (user) {
          return {
            currentUser: user
          };
        }
      }
      throw new Error("No JWT. Can't subscribe");
    }
  }
```

```typescript
// in graphQL server contructor step 4 - 5
this.app = new GraphQLServer({
  schema,
  context: req => {
    const { connection: { context = null } = {} } = req;
    return {
      req: req.request,
      pubSub: this.pubSub,
      context
    };
  }
});
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.70 Filtering Subscription Messages

## section.log

- filter subscription with `withFilter`

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.71 Filtering Subscription Messages part Two

## section.log

- finish `DriversSubscription` resolver
- filter drivers by drivers location

## tips

## issue

### getting user lastLat, lastLng

- in the lecture, there is no `async`, `await` on the second argument function of `withFilter`, check the below

```typescript
// the original code in the lecture
(payload, _, { context }) => {
  const user: User = context.currentUser;
  const {
    DriversSubscription: { lastLat: driverLastLat, lastLng: driverLastLng }
  } = payload;
  const { lastLat: userLastLat, lastLng: userLastLng } = user;
  return (
    driverLastLat <= userLastLat + 0.5 &&
    driverLastLat >= userLastLat - 0.5 &&
    driverLastLng <= userLastLng + 0.5 &&
    driverLastLng >= userLastLng - 0.5
  );
};
```

- In my case, as a result from the above<br>
  There wasn't any notification by listening driver's ReportMovement<br>
  So I just put `console.log`, to check the user and drivers information<br>
  After define `driverLastLat`, `driverLastLng`, `userLastLat`, `userLastLng`<br>
  Like below

```typescript
...
const {
    DriversSubscription: { lastLat: driverLastLat, lastLng: driverLastLng }
  } = payload;
  const { lastLat: userLastLat, lastLng: userLastLng } = user;
  console.log(`users lat, lng = { ${userLastLat}, ${userLastLng} }`);
  console.log(`drivers lat, lng = { ${driverLastLat}, ${driverLastLng} }`);
  return (
...

// result
// users lat, lng = { undefined, undefined }
// drivers lat, lng = { 40.23, 9.72 }
```

- So i put `async`, `await` into the part that getting user

```typescript
async (payload, _, { context }) => {
  const user: User = await context.currentUser;
```

- And it works, I don't know why it needs `async`, `await`, even `currentUser` information is given as argument

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.72 RequestRide Resolver

## section.log

- define `RequestRide` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.73 GetNearbyRides Resolver

## section.log

- define `GetNearbyRides` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.74 NearbyRideSubscription

## section.log

- define `NearbyRidesSubscription` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.75 Testing the NearbyRideSubscription

## section.log

- test `NearbyRidesSubscription` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.76 UpdateRideStatus Resolver part One

## section.log

- define `UpdateRideStatus` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.77 UpdateRideStatus Resolver part Two

## section.log

- define `UpdateRideStatus` resolver

## tips

### ride status updating process:

1.  driver gets a ride information which is reported around them and having status 'REQUESTING'
2.  if that ride be found, driver paticipates to the ride as a 'driver', updates `ride.driver = driver`(themselves)
3.  then, driver changes their `isTaken` status to be true
4.  finally, driver changes ride status to be 'ACCEPTED'

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

#1.79 RideStatusSubscription

## section.log

- define `RideStatusSubscription` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.80 Testing the RideStatusSubscription

## section.log

- test `RideStatusSubscription` resolver

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.81 Creating a ChatRoom

## section.log

- define creating Chat Room function
- creating chat room function in `UpdateRideStatus` resolver

## tips

- creating chat room function doesn't have resolver for that
- it automatically create when driver accept a ride request
- in `UpdateRideStatus`, after driver update ride status, define creating a chat room

```typescript
...
// UpdateRideStatus resolver
if (ride) {
    ride.driver = user;
    user.isTaken = true;
    user.save();
    // after driver update ride status, creat a chat
    await Chat.create({
        driver: user,
        passenger: ride.passenger
        }).save();
    }
...
```

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.82 GetChat Resolver

## section.log

- define `GetChat` resolver
- adjust model (User, Chat)

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---

# 1.83 BugFixing

## section.log

- adjust `UpdateRideStatus`
- adjust `Chat`, `Ride` models

## tips

## issue

- none

## links

## added dependencies

### dependencies

### devDependencies

---
